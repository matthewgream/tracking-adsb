#!/usr/bin/node

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const { hostname } = require('os');
const configFile = process.argv[2] || `./config.js.${hostname}`;
const config = require(configFile);
console.error(`config: ${configFile}`);

const CACHE_EXPIRY_TIME = 5 * 60;
const ALERT_EXPIRY_TIME = 5 * 60;
const CYCLE_SCAN_TIME = 30;

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

let mqtt = null;
function publishInit(config) {
    if (!mqtt && config.mqtt && config.mqtt.enabled) {
        mqtt = require('./function-mqtt.js')(config.mqtt);
        mqtt.begin((topic, message) => console.log(`mqtt: received: '${topic}' => '${message}' [IGNORED]`));
    }
}
function publishTerm() {
    if (mqtt) mqtt.end();
}
function publish(config, type, sub, data) {
    if (mqtt && config.mqtt.publishTopics?.[type]) data.forEach((item) => mqtt.publish([config.mqtt.publishTopics[type], sub].join('/'), item));
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

function display(config, type, sub, data) {
    if (sub == 'insert')
        data.forEach((item) =>
            console.error(`${item.timeFormatted} ${type.toUpperCase()}/${sub} [${item.type}] ${item.flight} ${item.text}${item.warn ? ' WARNING' : ''}`)
        );
    //else if (sub == 'remove') data.forEach((item) => console.error(`${item} ${type.toUpperCase()}/${sub}`));
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const flightData = require('./data-flights.js');
const airportData = require('./data-airports.js');

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

function formatAltitude(altitude) {
    // Standard transition level in the UK is generally FL70 (7,000 ft)
    // London TMA uses varying transition altitudes, but 6,000 ft is common
    const transitionLevel = 7000;
    if (altitude === null || altitude === undefined) return 'n/a';
    if (altitude >= transitionLevel) return `FL${Math.round(altitude / 100)}`;
    if (altitude === 0) return 'ground';
    return `${altitude.toLocaleString()} ft`;
}

function getStats_List(name, list) {
    return {
        count: list.length,
        description: `${name}: ${list.length}` + (list.length > 0 ? ': ' + list.map((aircraft) => aircraft.flight).join(', ') : ''),
    };
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const helpers = require('./filter-helpers.js');

const filterModules = [
    require('./filter-emergency.js'),
    require('./filter-military.js'),
    require('./filter-vicinity.js'),
    require('./filter-airport.js'),
    require('./filter-overhead.js'),
    require('./filter-landing.js'),
    require('./filter-lifting.js'),
    require('./filter-airprox.js'),
    require('./filter-specific.js'),
    require('./filter-anomaly.js'),
    require('./filter-weather.js'),
];
const filterMap = Object.fromEntries(filterModules.map((module) => [module.id, module]));

function filterAircraft(lat, lon, aircraftList) {
    for (const aircraft of aircraftList) {
        aircraft.calculated = {};
        if (!aircraft.lat && !aircraft.lon && aircraft.lastPosition?.lat && aircraft.lastPosition?.lon) {
            aircraft.lat = aircraft.lastPosition.lat;
            aircraft.lon = aircraft.lastPosition.lon;
            aircraft.calculated.position = true;
        }
        if (aircraft.lat && aircraft.lon) {
            aircraft.calculated.distance = helpers.calculateDistance(lat, lon, aircraft.lat, aircraft.lon);
            if (aircraft.track) aircraft.calculated.positionRelative = helpers.calculateRelativePosition(lat, lon, aircraft.lat, aircraft.lon, aircraft.track);
        }
        aircraft.calculated.altitude = aircraft.alt_baro || aircraft.alt_geom;
        if (aircraft.calculated.altitude === 'ground') aircraft.calculated.altitude = 0;
        if (typeof aircraft.calculated.altitude !== 'number') delete aircraft.calculated.altitude;
    }
    const filtered = [];
    const filters = filterModules.filter((f) => f.enabled);
    for (const aircraft of aircraftList) {
        for (const filter of filters) filter.preprocess(aircraft, aircraftList);
        if (filters.some((filter) => filter.evaluate(aircraft))) filtered.push(aircraft);
    }
    return filtered.sort((a, b) => {
        const aFilters = filters.filter((f) => f.evaluate(a)),
            bFilters = filters.filter((f) => f.evaluate(b));
        if (aFilters.length === 0 || bFilters.length === 0) {
            if (a.calculated.distance === undefined && b.calculated.distance === undefined) return 0;
            if (a.calculated.distance === undefined) return 1;
            if (b.calculated.distance === undefined) return -1;
            return a.calculated.distance - b.calculated.distance;
        }
        const aHighestPriority = Math.min(...aFilters.map((f) => f.priority)),
            bHighestPriority = Math.min(...bFilters.map((f) => f.priority));
        return aHighestPriority !== bHighestPriority ? aHighestPriority - bHighestPriority : filters.find((f) => f.priority === aHighestPriority).sort(a, b);
    });
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

async function obtain(conf) {
    try {
        const data = await flightData.fetch(conf.link);
        const aircraft = filterAircraft(conf.location.lat, conf.location.lon, data.aircraft);
        const status = {
            receivedAircraftCount: data.aircraft.length,
            selectedAircraftCount: aircraft.length,
            filterStats: Object.fromEntries(filterModules.filter((f) => f.enabled).map((filter) => [filter.id, filter.getStats(aircraft)])),
        };
        const now = Date.now();
        aircraft.forEach((a) => (a.calculated.timestamp_updated = now));
        return { data: { ...data, aircraft }, status };
    } catch (error) {
        return {
            data: null,
            status: {
                error: error.message,
            },
        };
    }
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const cache = {};

function track(data) {
    if (data.aircraft?.length > 0) {
        const now = Date.now();
        const currentHexes = new Set();
        data.aircraft
            .filter((aircraft) => aircraft.hex)
            .forEach((aircraft) => {
                const hex = aircraft.hex;
                currentHexes.add(hex);
                if (!cache[hex])
                    cache[hex] = {
                        ...aircraft,
                        processing: {
                            first_seen: now,
                            appearances: 1,
                            missed_updates: 0,
                            consecutive_misses: 0,
                            consecutive_appearances: 1,
                        },
                    };
                else
                    cache[hex] = {
                        ...aircraft,
                        processing: {
                            ...cache[hex].processing,
                            appearances: cache[hex].processing.appearances + 1,
                            consecutive_misses: 0,
                            consecutive_appearances: cache[hex].processing.consecutive_appearances + 1,
                        },
                    };
            });
        Object.entries(cache)
            .filter(([hex, entry]) => !currentHexes.has(hex) && now - entry.calculated.timestamp_updated <= CACHE_EXPIRY_TIME * 1000)
            .forEach(([_, entry]) => {
                entry.processing.missed_updates += 1;
                entry.processing.consecutive_misses += 1;
                entry.processing.consecutive_appearances = 0;
            });
        Object.entries(cache)
            .filter(([_, entry]) => now - entry.calculated.timestamp_updated > CACHE_EXPIRY_TIME * 1000)
            .forEach(([hex, _]) => delete cache[hex]);
        data = { ...data, aircraft: Object.values(cache) };
    }
    return data;
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const alertsActive = {};

function alerts(processedData, stats) {
    const time = Date.now();
    const alerts = Object.keys(filterMap)
        .filter((key) => stats[key])
        .flatMap((key) =>
            processedData.aircraft
                .filter((aircraft) => filterMap[key].evaluate(aircraft))
                .map((aircraft) => {
                    const id = `aircraft-${key}-${aircraft.hex}`;
                    if (alertsActive[id]) {
                        alertsActive[id].timeLast = time;
                        return undefined;
                    }
                    const alert = {
                        id,
                        time,
                        timeFormatted: new Date(time).toISOString(),
                        type: 'aircraft-' + key,
                        ...alertMeta(filterMap[key].format, aircraft),
                        flight: aircraft.flight,
                        timeLast: time,
                    };
                    alertsActive[id] = alert;
                    return alert;
                })
                .filter(Boolean)
        );
    // should really remove if they do not come through the filter again and a specific threshold
    const alertsRemoved = Object.entries(alertsActive)
        .filter(([_, alert]) => time - alert.timeLast > ALERT_EXPIRY_TIME * 1000)
        .map(([id, _]) => {
            delete alertsActive[id];
            return id;
        });
    return {
        alertsInserted: alerts,
        alertsRemoved,
        alertsActive: Object.values(alertsActive),
    };
}

function alertStats() {
    return Object.entries(Object.values(alertsActive).reduce((list, alert) => ({ ...list, [alert.type]: (list[alert.type] || 0) + 1 }), {}))
        .sort((a, b) => a[0].localeCompare(b[0]))
        .map(([key, count]) => `${key}=${count}`)
        .join(', ');
}

function alertMeta(format, aircraft) {
    const aircraftType = aircraft.category || '';
    const priorityType =
        aircraft.calculated.is_emergency ||
        aircraft.calculated.is_military ||
        (aircraft.calculated.landing && aircraft.calculated.landing.willIntersectGround && aircraft.calculated.is_proximate) ||
        (aircraft.calculated.lifting && aircraft.calculated.lifting.isTakingOff && aircraft.calculated.is_proximate);

    const positionInfo = aircraft.calculated.positionRelative
        ? ` (${aircraft.calculated.distance.toFixed(1)}km ${aircraft.calculated.positionRelative.cardinalBearing} ${formatAltitude(aircraft.calculated.altitude)})`
        : '';
    const aircraftInfo = aircraftType ? ` <${aircraftType}>` : '';

    const meta = {
        text: `detected`,
        warn: priorityType,
        position: aircraft.calculated.positionRelative,
        altitude: aircraft.calculated.altitude,
        aircraftType,
    };
    if (aircraft.gs) meta.speed = `${Math.round(aircraft.gs)} kts`;

    const details = { ...meta, ...format(aircraft) };
    if (details.text) details.text += `${aircraftInfo}${positionInfo}`;

    return details;
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

function init(config) {
    console.error('***');
    config.airports = airportData.findNearby(config.location.lat, config.location.lon, { distance: config.tracking.vicinity.distance });
    console.error('config:', config);
    const extra = { data: { airports: airportData }, format: { getStats_List, formatAltitude } };
    filterModules.forEach((module) => module.config(config, extra));
    publishInit(config.publish);
    process.on('exit', () => publishTerm());
}

async function loop(config) {
    try {
        console.error('***');
        const { data, status } = await obtain(config);
        //console.error('status: ' + JSON.stringify(status));
        if (data) {
            const processedData = track(data);
            const alertInfo = alerts(processedData, status.filterStats);
            if (alertInfo.alertsInserted.length > 0) {
                publish(config.publish, 'alert', 'insert', alertInfo.alertsInserted);
                display(config.display, 'alert', 'insert', alertInfo.alertsInserted);
            }
            if (alertInfo.alertsRemoved.length > 0) {
                publish(config.publish, 'alert', 'remove', alertInfo.alertsRemoved);
                display(config.display, 'alert', 'remove', alertInfo.alertsRemoved);
            }
            // XXX publishStatus/displayStatus
            console.error(`${new Date().toISOString()} ALERT/status new=${alertInfo.alertsInserted.length}/all=${alertInfo.alertsActive.length}: ${alertStats()}`);
        } else console.error('No data received');
    } catch (error) {
        console.error(`Error in loop: ${error.message}`);
    }
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------

init(config);
loop(config);
setInterval(() => loop(config), CYCLE_SCAN_TIME * 1000);

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------
