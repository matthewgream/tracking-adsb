#!/usr/bin/node

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const { hostname } = require('os');
const configFile = process.argv[2] || `./config.${hostname}.js`;
const config = require(configFile);
console.error(`config: ${configFile}`);

const CACHE_EXPIRY_TIME = 5 * 60;
const ALERT_EXPIRY_TIME = 5 * 60;
const CYCLE_SCAN_TIME = 30;

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

let mqtt;
function publishInit(config) {
    if (!mqtt && config.mqtt && config.mqtt.enabled) {
        mqtt = require('./function-mqtt.js')(config.mqtt);
        mqtt.begin((topic, message) => console.log(`mqtt: received: '${topic}' => '${message}' [IGNORED]`));
    }
}
function publishTerm() {
    if (mqtt) mqtt.end();
}
function publish(config, type, sub, data) {
    if (mqtt && config.mqtt.publishTopics?.[type]) data.forEach((item) => mqtt.publish([config.mqtt.publishTopics[type], sub].join('/'), item));
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

function display(config, type, sub, data) {
    if (sub == 'insert')
        data.forEach((item) =>
            console.error(`${item.timeFormatted} ${type.toUpperCase()}/${sub} [${item.type}] ${item.flight} ${item.text}${item.warn ? ' [NOTICE]' : ''}`)
        );
    //else if (sub == 'remove') data.forEach((item) => console.error(`${item} ${type.toUpperCase()}/${sub}`));
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

function formatAltitude(altitude) {
    // Standard transition level in the UK is generally FL70 (7,000 ft)
    // London TMA uses varying transition altitudes, but 6,000 ft is common
    const transitionLevel = 7000;
    if (altitude === undefined) return 'n/a';
    if (altitude >= transitionLevel) return `FL${Math.round(altitude / 100)}`;
    if (altitude === 0) return 'ground';
    return `${altitude.toLocaleString()} ft`;
}

function formatStatsList(name, list) {
    return {
        count: list.length,
        description: `${name}: ${list.length}` + (list.length > 0 ? ': ' + list.map((aircraft) => aircraft.flight).join(', ') : ''),
    };
}

function formatAirport(airport) {
    const { name, icao } = airport || {};
    if (name && icao) return `${icao} [${name}]`;
    if (name) return name;
    if (icao) return icao;
    return '';
}

function formatVerticalAngle(angle) {
    if (angle < 0) return 'below horizon'; // For very distant aircraft below observer altitude
    if (angle < 5) return 'just above horizon';
    if (angle < 15) return 'low in sky';
    if (angle < 30) return 'midway up';
    if (angle < 60) return 'high in sky';
    if (angle < 80) return 'nearly overhead';
    return 'directly overhead';
}

// eslint-disable-next-line sonarjs/cognitive-complexity
function formatTimePhrase(seconds, isFuture) {
    const totalSecs = Math.abs(seconds);
    const mins = Math.floor(totalSecs / 60),
        secs = totalSecs % 60;
    if (isFuture) {
        if (totalSecs < 30) return `in ${totalSecs} seconds`;
        if (totalSecs < 90) return secs > 45 ? `in just over a minute` : `in about a minute`;
        if (mins < 5) return secs > 30 ? `in about ${mins + 1} minutes` : `in about ${mins} minutes`;
        return `in about ${mins} minutes`;
    } else {
        if (totalSecs < 30) return `just now`;
        if (totalSecs < 90) return `about a minute ago`;
        return `about ${mins} minutes ago`;
    }
}

function formatCategoryCode(categoryCode) {
    if (!categoryCode) return '';
    const categoryDescriptions = {
        A0: 'No Information',
        A1: 'Light (<15.5k lbs)',
        A2: 'Small (15.5-75k lbs)',
        A3: 'Large (75-300k lbs)',
        A4: 'High-Vortex Large (B757)',
        A5: 'Heavy (>300k lbs)',
        A6: 'High Performance (>5g and >400 kts)',
        A7: 'Rotorcraft',
        B0: 'No Information',
        B1: 'Glider/Sailplane',
        B2: 'Lighter-than-air',
        B3: 'Parachutist/Skydiver',
        B4: 'Ultralight/hang-glider/paraglider',
        B5: 'Reserved',
        B6: 'UAV/Drone',
        B7: 'Space/Trans-atmospheric vehicle',
        C0: 'No Information',
        C1: 'Surface - Emergency Vehicle',
        C2: 'Surface - Service Vehicle',
        C3: 'Point Obstacle (incl. balloons)',
        C4: 'Cluster Obstacle',
        C5: 'Line Obstacle',
        C6: 'Reserved',
        C7: 'Reserved',
        D0: 'No Information',
        D1: 'Reserved',
        D2: 'Reserved',
        D3: 'Reserved',
        D4: 'Reserved',
        D5: 'Reserved',
        D6: 'Reserved',
        D7: 'Reserved',
    };
    const description = categoryDescriptions[categoryCode];
    return description ? `${categoryCode}: ${description}` : `${categoryCode}`;
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const helpers = require('./filter-helpers.js');

function preprocessAircraft(lat, lon, aircraftList) {
    for (const aircraft of aircraftList) {
        aircraft.calculated = {};
        if (!aircraft.lat && !aircraft.lon && aircraft.lastPosition?.lat && aircraft.lastPosition?.lon) {
            aircraft.lat = aircraft.lastPosition.lat;
            aircraft.lon = aircraft.lastPosition.lon;
            aircraft.calculated.position = true;
        }
        if (aircraft.lat && aircraft.lon) {
            aircraft.calculated.distance = helpers.calculateDistance(lat, lon, aircraft.lat, aircraft.lon);
            if (aircraft.track) aircraft.calculated.positionRelative = helpers.calculateRelativePosition(lat, lon, aircraft.lat, aircraft.lon, aircraft.track);
        }
        aircraft.calculated.altitude = aircraft.alt_baro ?? aircraft.alt_geom;
        if (aircraft.calculated.altitude === 'ground') aircraft.calculated.altitude = 0;
        if (aircraft.calculated.altitude === null || typeof aircraft.calculated.altitude !== 'number') delete aircraft.calculated.altitude;
    }
    return aircraftList;
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const filterModules = [
    require('./filter-emergency.js'),
    require('./filter-military.js'),
    require('./filter-vicinity.js'),
    require('./filter-airport.js'),
    require('./filter-overhead.js'),
    require('./filter-landing.js'),
    require('./filter-lifting.js'),
    require('./filter-airprox.js'),
    require('./filter-specific.js'),
    require('./filter-anomaly.js'),
    require('./filter-weather.js'),
];

const filterMap = Object.fromEntries(filterModules.map((module) => [module.id, module]));

function filterAircraft(aircraftList) {
    const filters = filterModules.filter((f) => f.enabled);
    const filtered = [];
    for (const aircraft of aircraftList) {
        for (const filter of filters) filter.preprocess(aircraft, aircraftList);
        if (filters.some((filter) => filter.evaluate(aircraft))) filtered.push(aircraft);
    }
    for (const filter of filters) if (filter.postprocess) filter.postprocess();
    return filtered.sort((a, b) => {
        const aFilters = filters.filter((f) => f.evaluate(a)),
            bFilters = filters.filter((f) => f.evaluate(b));
        if (aFilters.length === 0 || bFilters.length === 0) {
            if (a.calculated.distance === undefined && b.calculated.distance === undefined) return 0;
            if (a.calculated.distance === undefined) return 1;
            if (b.calculated.distance === undefined) return -1;
            return a.calculated.distance - b.calculated.distance;
        }
        const aHighestPriority = Math.min(...aFilters.map((f) => f.priority)),
            bHighestPriority = Math.min(...bFilters.map((f) => f.priority));
        return aHighestPriority === bHighestPriority ? filters.find((f) => f.priority === aHighestPriority).sort(a, b) : aHighestPriority - bHighestPriority;
    });
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

let preprocess_exclude;
function fixup(config, data) {
    if (config.flights?.exclude) {
        if (!preprocess_exclude && config.flights.exclude) preprocess_exclude = new Set(config.flights.exclude);
        if (preprocess_exclude && data.aircraft)
            data.aircraft = data.aircraft.filter((aircraft) => !aircraft.flight || !preprocess_exclude.has(aircraft.flight));
    }
    return data;
}

async function obtain(flightData, config) {
    try {
        let data = await flightData.fetch(config.link);
        data = fixup(config, data);
        let aircraft = preprocessAircraft(config.location.lat, config.location.lon, data.aircraft);
        aircraft = filterAircraft(aircraft);
        const status = {
            receivedAircraftCount: data.aircraft.length,
            selectedAircraftCount: aircraft.length,
            filterStats: Object.fromEntries(filterModules.filter((f) => f.enabled).map((filter) => [filter.id, filter.getStats(aircraft)])),
        };
        const now = Date.now();
        aircraft.forEach((a) => (a.calculated.timestamp_updated = now));
        return { data: { ...data, aircraft }, status };
    } catch (e) {
        return {
            status: {
                error: e.message,
            },
        };
    }
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const cache = {};

function track(data) {
    if (data.aircraft?.length > 0) {
        const now = Date.now();
        const currentHexes = new Set();
        data.aircraft
            .filter((aircraft) => aircraft.hex)
            .forEach((aircraft) => {
                const { hex } = aircraft;
                currentHexes.add(hex);
                cache[hex] = {
                    ...aircraft,
                    processing: {
                        first_seen: cache?.[hex]?.processing?.first_seen || now,
                        missed_updates: cache?.[hex]?.processing?.missed_updates || 0,
                        appearances: (cache?.[hex]?.processing?.appearances || 0) + 1,
                        consecutive_misses: 0,
                        consecutive_appearances: (cache?.[hex]?.processing?.consecutive_appearances || 0) + 1,
                    },
                };
            });
        Object.entries(cache)
            .filter(([hex, entry]) => !currentHexes.has(hex) && now - entry.calculated.timestamp_updated <= CACHE_EXPIRY_TIME * 1000)
            .forEach(([_, entry]) => {
                entry.processing.missed_updates += 1;
                entry.processing.consecutive_misses += 1;
                entry.processing.consecutive_appearances = 0;
            });
        Object.entries(cache)
            .filter(([_, entry]) => now - entry.calculated.timestamp_updated > CACHE_EXPIRY_TIME * 1000)
            .forEach(([hex, _]) => delete cache[hex]);
        data = { ...data, aircraft: Object.values(cache) };
    }
    return data;
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

const alertsActive = {};

function alerts(config, processedData, stats) {
    const time = Date.now();
    const alerts = Object.keys(filterMap)
        .filter((key) => stats[key])
        .flatMap((key) =>
            processedData.aircraft
                .filter((aircraft) => filterMap[key].evaluate(aircraft))
                .map((aircraft) => {
                    const id = `aircraft-${key}-${aircraft.hex}`;
                    if (alertsActive[id]) {
                        alertsActive[id].timeLast = time;
                        return undefined;
                    }
                    const alert = {
                        id,
                        time,
                        timeFormatted: new Date(time).toISOString(),
                        type: 'aircraft-' + key,
                        ...alertMeta(filterMap[key].format, aircraft),
                        flight: aircraft.flight,
                        timeLast: time,
                    };
                    if (alert.warn && config?.warn_suppress?.[key]) alert.warn = false;
                    alertsActive[id] = alert;
                    return alert;
                })
                .filter(Boolean)
        );
    // should really remove if they do not come through the filter again and a specific threshold
    const alertsRemoved = Object.entries(alertsActive)
        .filter(([_, alert]) => time - alert.timeLast > ALERT_EXPIRY_TIME * 1000)
        .map(([id, _]) => {
            delete alertsActive[id];
            return id;
        });
    return {
        alertsInserted: alerts,
        alertsRemoved,
        alertsActive: Object.values(alertsActive),
    };
}

function alertStats() {
    return Object.entries(Object.values(alertsActive).reduce((list, alert) => ({ ...list, [alert.type]: (list[alert.type] || 0) + 1 }), {}))
        .sort((a, b) => a[0].localeCompare(b[0]))
        .map(([key, count]) => `${key}=${count}`)
        .join(', ');
}

function alertMeta(format, aircraft) {
    const aircraftType = aircraft.category || '';
    const priorityType =
        aircraft.calculated.is_emergency ||
        aircraft.calculated.is_military ||
        (aircraft.calculated.is_proximate && (aircraft.calculated.landing?.isLanding || aircraft.calculated.lifting?.isLifting));

    const { positionRelative: position, distance, altitude } = aircraft.calculated;
    const positionInfo = position ? ` (${distance.toFixed(1)}km ${position.cardinalBearing} ${formatAltitude(altitude)})` : '';
    const aircraftInfo = aircraftType ? ` <${formatCategoryCode(aircraftType)}>` : '';

    const meta = {
        text: `detected`,
        warn: priorityType,
        position,
        altitude,
        speed: aircraft.gs ? `${Math.round(aircraft.gs)} kts` : undefined,
        aircraftType,
    };

    const details = { ...meta, ...format(aircraft) };
    if (details.text) details.text += `${aircraftInfo}${positionInfo}`;

    return details;
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

let flightData;

function init(config) {
    console.error('***');
    console.error('config:', config);
    flightData = require('./data-flights.js');
    const airportData = require('./data-airports.js')(config.airports);
    const airportText = [`${airportData.length()} loaded`];
    if (config.range_max) {
        const airportInRange = airportData.findNearby(config.location.lat, config.location.lon, { distance: helpers.nmToKm(config.range_max) });
        airportText.push(`${airportInRange.length} in range (${config.range_max}nm/${helpers.nmToKm(config.range_max).toFixed(0)}km)`);
    }
    if (config.filters.vicinity.distance) {
        const airportVicinity = airportData.findNearby(config.location.lat, config.location.lon, { distance: config.filters.vicinity.distance });
        airportText.push(
            `${airportVicinity.length} in vicinity (${config.filters.vicinity.distance}km): ${airportVicinity.map((airport) => formatAirport(airport)).join(' ,')}`
        );
    }
    console.error(`airports: ${airportText.join('; ')}`);
    const extra = {
        data: { airports: airportData, location: config.location },
        format: { formatStatsList, formatAltitude, formatAirport, formatVerticalAngle, formatTimePhrase },
    };
    filterModules.forEach((module) => module.config(config.filters[module.id], extra));
    publishInit(config.publish);
    process.on('exit', () => publishTerm());
}

async function loop(config) {
    try {
        const { data, status } = await obtain(flightData, config);
        //console.error('status: ' + JSON.stringify(status));
        if (data) {
            const processedData = track(data);
            const alertInfo = alerts(config.alerts, processedData, status.filterStats);
            if (alertInfo.alertsInserted.length > 0) {
                publish(config.publish, 'alert', 'insert', alertInfo.alertsInserted);
                display(config.display, 'alert', 'insert', alertInfo.alertsInserted);
            }
            if (alertInfo.alertsRemoved.length > 0) {
                publish(config.publish, 'alert', 'remove', alertInfo.alertsRemoved);
                display(config.display, 'alert', 'remove', alertInfo.alertsRemoved);
            }
            // XXX publishStatus/displayStatus
            console.error(
                `${new Date().toISOString()} ALERT/status new=${alertInfo.alertsInserted.length}/all=${alertInfo.alertsActive.length}/src=${data.aircraft.length}: ${alertStats()}`
            );
        } else console.error(`No data received: ${status.error || 'no error details'}`);
    } catch (e) {
        console.error(`Error in loop: ${e.message}`);
    }
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------

init(config);
loop(config);
setInterval(() => loop(config), CYCLE_SCAN_TIME * 1000);

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------------
